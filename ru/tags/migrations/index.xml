<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>migrations on Сайт memclutter'а</title><link>https://memclutter.me/ru/tags/migrations/</link><description>Recent content in migrations on Сайт memclutter'а</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© memclutter 2022</copyright><lastBuildDate>Sat, 12 Nov 2022 15:30:19 +0300</lastBuildDate><atom:link href="https://memclutter.me/ru/tags/migrations/index.xml" rel="self" type="application/rss+xml"/><item><title>Django Migrations: Делаем миграцию не так как хочет Django</title><link>https://memclutter.me/ru/django-separate-migrations/</link><pubDate>Sat, 12 Nov 2022 15:30:19 +0300</pubDate><guid>https://memclutter.me/ru/django-separate-migrations/</guid><description>Django migrations, как и сам django, это просто волшебный инструмент. Но при этом &amp;ldquo;волшебство&amp;rdquo; порой мешает сделать задачу как нужно. Одно из таких &amp;ldquo;волшебств&amp;rdquo;, связано с созданием индекса в PostgreSQL без блокировки на запись. Подробнее об этом есть в документацаии.
Стандартный migrations.AddIndex, который создается автоматически при добавлении индекса в модель, выполняет обычный CREATE INDEX ... и если мы хотим выкатить быстренько в прод и не заблочить запись в таблицу, то нужно отделить django models state и фактический заапрос в SQL.</description></item></channel></rss>